ccopy_reg
_reconstructor
p1
(c__main__
LogisticRegression
p2
c__builtin__
object
p3
NtRp4
(dp5
S'b'
g1
(ctheano.tensor.sharedvar
TensorSharedVariable
p6
g3
NtRp7
(dp8
S'auto_name'
p9
S'auto_22'
p10
sS'index'
p11
NsS'tag'
p12
g1
(ctheano.gof.utils
scratchpad
p13
g3
NtRp14
(dp15
S'trace'
p16
(lp17
(lp18
(S'ternary.py'
p19
I368
S'<module>'
p20
S'sgd_optimization_mnist()'
tp21
a(S'ternary.py'
p22
I195
S'sgd_optimization_mnist'
p23
S'classifier = LogisticRegression(input=x, n_in=20, n_out=3)'
tp24
a(S'ternary.py'
p25
I29
S'__init__'
p26
S"), name='b', borrow=True)"
tp27
aasbsS'container'
p28
g1
(ctheano.gof.link
Container
p29
g3
NtRp30
(dp31
S'name'
p32
S'b'
sS'storage'
p33
(lp34
cnumpy.core.multiarray
_reconstruct
p35
(cnumpy
ndarray
p36
(I0
tS'b'
tRp37
(I1
(I3
tcnumpy
dtype
p38
(S'f8'
I0
I1
tRp39
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'f\xec\x88X\x15\xb8\xe5\xbfW0\xab\xe7\xc0\xf1\xc0\xbf\x83\xb8s\x92\x85\xf4\xe9?'
tbasS'strict'
p40
I00
sS'readonly'
p41
I00
sS'type'
p42
g1
(ctheano.tensor.type
TensorType
p43
g3
NtRp44
(dp45
S'broadcastable'
p46
(I00
tp47
sS'dtype'
p48
S'float64'
p49
sS'numpy_dtype'
p50
g39
sS'sparse_grad'
p51
I00
sg32
NsbsS'allow_downcast'
p52
Nsbsg32
S'b'
sS'owner'
p53
Nsg42
g44
sbsS'y_pred'
p54
g1
(ctheano.tensor.var
TensorVariable
p55
g3
NtRp56
(dp57
g9
S'auto_31'
p58
sg11
I1
sg12
g1
(g13
g3
NtRp59
(dp60
g16
(lp61
(lp62
(g19
I368
g20
S'sgd_optimization_mnist()'
tp63
a(g22
I195
g23
S'classifier = LogisticRegression(input=x, n_in=20, n_out=3)'
tp64
a(g25
I33
g26
S'self.y_pred = T.argmax(self.p_y_given_x, axis=1)'
tp65
aasbsg32
S'argmax'
p66
sg53
g1
(ctheano.gof.graph
Apply
p67
g3
NtRp68
(dp69
S'inputs'
p70
(lp71
g1
(g55
g3
NtRp72
(dp73
g9
S'auto_29'
p74
sg11
I0
sg12
g1
(g13
g3
NtRp75
(dp76
g16
(lp77
(lp78
(g19
I368
g20
S'sgd_optimization_mnist()'
tp79
a(g22
I195
g23
S'classifier = LogisticRegression(input=x, n_in=20, n_out=3)'
tp80
a(g25
I31
g26
S'self.p_y_given_x = T.nnet.softmax(T.dot(input, self.W) + self.b)'
tp81
aasbsg32
Nsg53
g1
(g67
g3
NtRp82
(dp83
g70
(lp84
g1
(g55
g3
NtRp85
(dp86
g9
S'auto_28'
p87
sg11
I0
sg12
g1
(g13
g3
NtRp88
(dp89
g16
(lp90
(lp91
(g19
I368
g20
S'sgd_optimization_mnist()'
tp92
a(g22
I195
g23
S'classifier = LogisticRegression(input=x, n_in=20, n_out=3)'
tp93
a(g25
I31
g26
S'self.p_y_given_x = T.nnet.softmax(T.dot(input, self.W) + self.b)'
tp94
aasbsg32
Nsg53
g1
(g67
g3
NtRp95
(dp96
g70
(lp97
g1
(g55
g3
NtRp98
(dp99
g9
S'auto_23'
p100
sg11
I0
sg12
g1
(g13
g3
NtRp101
(dp102
g16
(lp103
(lp104
(g19
I368
g20
S'sgd_optimization_mnist()'
tp105
a(g22
I195
g23
S'classifier = LogisticRegression(input=x, n_in=20, n_out=3)'
tp106
a(g25
I31
g26
S'self.p_y_given_x = T.nnet.softmax(T.dot(input, self.W) + self.b)'
tp107
aasbsg32
Nsg53
g1
(g67
g3
NtRp108
(dp109
g70
(lp110
g1
(g55
g3
NtRp111
(dp112
g9
S'auto_19'
p113
sg11
Nsg12
g1
(g13
g3
NtRp114
(dp115
g16
(lp116
(lp117
(g19
I368
g20
S'sgd_optimization_mnist()'
tp118
a(g22
I192
g23
S"x = T.matrix('x')  # data, presented as rasterized images"
tp119
aasbsg32
S'x'
sg53
Nsg42
g1
(g43
g3
NtRp120
(dp121
g46
(I00
I00
tp122
sg48
S'float64'
p123
sg50
g39
sg51
I00
sg32
Nsbsbag1
(g6
g3
NtRp124
(dp125
g9
S'auto_21'
p126
sg11
Nsg12
g1
(g13
g3
NtRp127
(dp128
g16
(lp129
(lp130
(g19
I368
g20
S'sgd_optimization_mnist()'
tp131
a(g22
I195
g23
S'classifier = LogisticRegression(input=x, n_in=20, n_out=3)'
tp132
a(g25
I22
g26
S"), name='W', borrow=True)"
tp133
aasbsg28
g1
(g29
g3
NtRp134
(dp135
g32
S'W'
sg33
(lp136
g35
(g36
(I0
tS'b'
tRp137
(I1
(I20
I3
tg39
I00
S'bm\x13\xc2\x03g\xd0\xbfg\xd8\x0c4\xfb\xcc\xb9?\xb1n \xea\x89\xe7\xc3?+\xc3\xb1\xc9\xc1\xf1\xbc\xbfar\x90\x9f0^\xad?\xf5\x13\xd3\xf3R\x85\xac?\xa6\xed\x88\xc72"\xd6?V\xeePhsv\xb3\xbf"\xb2t\xed\x95D\xd1\xbfl"/\xbf:*\xac\xbf\xb7\x12\x9cZ\xb0\xc4\x9b\xbf\xf3\x95>vI\x06\xb5?\xe9?\xca!\xa3\xc7\xc3?\x8e\xecB\x04h\xbf\xac?\xf0\xfa\xda"}\xf7\xca\xbf\xc7\xb0\xc3\xb6P8\xc2?-\xe4{\xf3\x87\xd4\xac\xbfwo\xc9s]\x06\xb6\xbf\xc7\xb0\xc3\xb6P8\xc2\xbf-\xe4{\xf3\x87\xd4\xac?wo\xc9s]\x06\xb6?J\x1bkM\xe1x\xe4\xbf\x07$\xe1q\xc6\xd0\xe4\xbf\xc6\x1f\xa6\xdf\xd3\xa4\xf4?\xb2a}\xadR\xbf\xef?\\\x19\xac\x1c-\xea\xec\xbf\xb3B\x8a\x86,\xa9\xb6\xbf\xc4P\xe7\xfe\x1f\x8b\xc2\xbfE{\x06a\x89\xee\xca\xbf\x1d\xe6\xf6\xaf\xd4\xbc\xd6?\xc9\xb9\x18\x849\xe6\xb2\xbfE\xa7\x95\x1e.\x83\x9b\xbf\xb2#\xbe\x0b\x05\xc7\xb9?\x12\xe0,[hX\xe6?\xcc\x9dq\t\x13\x04\xd8\xbfv"\xe8\xac\xbd\xac\xd4\xbfn\xd9\x1a\x19n\xce\xcc\xbf\t\xaa\xd2/"\x1b\x01\xc0\xa5Wd\x11\t\xe8\x02@5\xa0f\x85\xa2\xc9\xf3\xbf\xe5^zk\xda\xeb\xe2?n\xe1R\x9fj\xa7\xe4?\xe4hC>\xafC\xf0?i+Z\x8a\x07\xe1\xe4\xbf\xb3LY\xe4\xadL\xd7\xbf\xab\xf6Y\xd3\xb8\\\xc8\xbf\x0b\xb2\xc80(\xb3\x97?F\xe0@\xcdSf\xc5?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1b\xa6\x87\xc4\xd5\x83\xe0\xbfZ**=\x1fn\xc7?\xd36z\xea\x9bP\xd5?p\xfa^\xbb\x10\xbf\xc7?\rOz\x05On\xc9?\xcb\xa4l\xe0\xaf\x96\xd8\xbf\xe4\x98K\xf7\xe52\xfb?U\x83\x84a\xbd\x80\xf1\xbf\x15+\x8e+Qd\xe3\xbf'
tbasg40
I00
sg41
I00
sg42
g1
(g43
g3
NtRp138
(dp139
g46
(I00
I00
tp140
sg48
S'float64'
p141
sg50
g39
sg51
I00
sg32
Nsbsg52
Nsbsg32
S'W'
sg53
Nsg42
g138
sbasg12
g1
(g13
g3
NtRp142
sS'outputs'
p143
(lp144
g98
asS'op'
p145
g1
(ctheano.tensor.basic
Dot
p146
g3
NtRp147
sbsg42
g1
(g43
g3
NtRp148
(dp149
g46
(I00
I00
tp150
sg48
S'float64'
p151
sg50
g39
sg51
I00
sg32
Nsbsbag1
(g55
g3
NtRp152
(dp153
g9
S'auto_27'
p154
sg11
I0
sg12
g1
(g13
g3
NtRp155
(dp156
g16
(lp157
(lp158
(g19
I368
g20
S'sgd_optimization_mnist()'
tp159
a(g22
I195
g23
S'classifier = LogisticRegression(input=x, n_in=20, n_out=3)'
tp160
a(g25
I31
g26
S'self.p_y_given_x = T.nnet.softmax(T.dot(input, self.W) + self.b)'
tp161
aasbsg32
Nsg53
g1
(g67
g3
NtRp162
(dp163
g70
(lp164
g7
asg12
g1
(g13
g3
NtRp165
sg143
(lp166
g152
asg145
g1
(ctheano.tensor.elemwise
DimShuffle
p167
g3
NtRp168
(dp169
S'input_broadcastable'
p170
g47
sS'shuffle'
p171
(lp172
I0
asS'augment'
p173
(lp174
I0
asS'drop'
p175
(lp176
sS'inplace'
p177
I01
sS'new_order'
p178
(S'x'
I0
tp179
sS'view_map'
p180
(dp181
I0
(lp182
I0
assbsbsg42
g1
(g43
g3
NtRp183
(dp184
g46
(I01
I00
tp185
sg48
g49
sg50
g39
sg51
I00
sg32
Nsbsbasg12
g1
(g13
g3
NtRp186
sg143
(lp187
g85
asg145
g1
(ctheano.tensor.elemwise
Elemwise
p188
g3
NtRp189
(dp190
S'__module__'
p191
S'tensor'
p192
sS'scalar_op'
p193
g1
(ctheano.scalar.basic
Add
p194
g3
NtRp195
(dp196
S'output_types_preference'
p197
ctheano.scalar.basic
upcast_out
p198
sg32
S'add'
p199
sbsg32
S'Elemwise{add,no_inplace}'
p200
sS'destroy_map'
p201
(dp202
sS'nfunc_spec'
p203
(g199
I2
I1
tp204
sS'inplace_pattern'
p205
g1
(ctheano.misc.frozendict
frozendict
p206
g3
NtRp207
(dp208
S'_hash'
p209
I0
sS'_dict'
p210
(dp211
sbsS'openmp'
p212
I00
sS'__doc__'
p213
S"elementwise addition\n\n    Generalizes a scalar op to tensors.\n\n    All the inputs must have the same number of dimensions. When the\n    Op is performed, for each dimension, each input's size for that\n    dimension must be the same. As a special case, it can also be 1\n    but only if the input's broadcastable flag is True for that\n    dimension. In that case, the tensor is (virtually) replicated\n    along that dimension to match the size of the others.\n\n    The dtypes of the outputs mirror those of the scalar Op that is\n    being generalized to tensors. In particular, if the calculations\n    for an output are done inplace on an input, the output type must\n    be the same as the corresponding input type (see the doc of\n    scalar.ScalarOp to get help about controlling the output type)\n\n    Parameters\n    ----------\n    scalar_op\n        An instance of a subclass of scalar.ScalarOp which works uniquely\n        on scalars.\n    inplace_pattern\n        A dictionary that maps the index of an output to the\n        index of an input so the output is calculated inplace using\n        the input's storage. (Just like destroymap, but without the lists.)\n    nfunc_spec\n        Either None or a tuple of three elements,\n        (nfunc_name, nin, nout) such that getattr(numpy, nfunc_name)\n        implements this operation, takes nin inputs and nout outputs.\n        Note that nin cannot always be inferred from the scalar op's\n        own nin field because that value is sometimes 0 (meaning a\n        variable number of inputs), whereas the numpy function may\n        not have varargs.\n\n    Note\n    ----\n    | Elemwise(add) represents + on tensors (x + y)\n    | Elemwise(add, {0 : 0}) represents the += operation (x += y)\n    | Elemwise(add, {0 : 1}) represents += on the second argument (y += x)\n    | Elemwise(mul)(rand(10, 5), rand(1, 5)) the second input is completed along the first dimension to match the first input\n    | Elemwise(true_div)(rand(10, 5), rand(10, 1)) same but along the second dimension\n    | Elemwise(int_div)(rand(1, 5), rand(10, 1)) the output has size (10, 5)\n    | Elemwise(log)(rand(3, 4, 5))\n\n    "
p214
sbsbsg42
g1
(g43
g3
NtRp215
(dp216
g46
(I00
I00
tp217
sg48
g123
sg50
g39
sg51
I00
sg32
Nsbsbasg12
g1
(g13
g3
NtRp218
sg143
(lp219
g72
asg145
g1
(ctheano.tensor.nnet.nnet
Softmax
p220
g3
NtRp221
sbsg42
g215
sbasg12
g1
(g13
g3
NtRp222
sg143
(lp223
g1
(g55
g3
NtRp224
(dp225
g9
S'auto_30'
p226
sg11
I0
sg12
g1
(g13
g3
NtRp227
(dp228
g16
(lp229
(lp230
(g19
I368
g20
S'sgd_optimization_mnist()'
tp231
a(g22
I195
g23
S'classifier = LogisticRegression(input=x, n_in=20, n_out=3)'
tp232
a(g25
I33
g26
S'self.y_pred = T.argmax(self.p_y_given_x, axis=1)'
tp233
aasbsg32
S'max'
p234
sg53
g68
sg42
g1
(g43
g3
NtRp235
(dp236
g46
(I00
tp237
sg48
g123
sg50
g39
sg51
I00
sg32
Nsbsbag56
asg145
g1
(ctheano.tensor.basic
MaxAndArgmax
p238
g3
NtRp239
(dp240
S'axis'
p241
(I1
tp242
sbsbsg42
g1
(g43
g3
NtRp243
(dp244
g46
(I00
tp245
sg48
S'int64'
p246
sg50
g38
(S'i8'
I0
I1
tRp247
(I3
S'<'
NNNI-1
I-1
I0
tbsg51
I00
sg32
NsbsbsS'params'
p248
(lp249
g124
ag7
asS'W'
g124
sS'input'
p250
g111
sS'p_y_given_x'
p251
g72
sb.